const Assignment = require('../model/assignment');
const UserInformation = require('../model/userInformation');

// Add Assignment
exports.addAssignment = async (req, res) => {
  try {
    const { teacherCode, assignmentName, subject, dueDate, status, assignedTo, questions } = req.body;

    // Validate required fields
    if (!teacherCode || !assignmentName || !subject || !dueDate || !assignedTo) {
      return res.status(400).json({
        success: false,
        message: 'All required fields must be provided: teacherCode, assignmentName, subject, dueDate, assignedTo'
      });
    }

    // Validate questions
    if (!questions || typeof questions !== 'object' || Object.keys(questions).length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Questions are required and must be an object'
      });
    }

    // Create assignment
    const assignment = new Assignment({
      teacherCode,
      assignmentName,
      subject,
      dueDate,
      assignedTo,
      questions
      // assignmentCode will be auto-generated by pre-save hook
    });

    await assignment.save();

    res.status(201).json({
      success: true,
      message: 'Assignment created successfully',
      data: assignment
    });
  } catch (error) {
    console.error('Error creating assignment:', error);
    res.status(500).json({
      success: false,
      message: 'Error creating assignment',
      error: error.message
    });
  }
};

// Student Submission
exports.submitAssignment = async (req, res) => {
  try {
    const { assignmentCode, studentCode, answers } = req.body;

    // Validate required fields
    if (!assignmentCode || !studentCode || !answers) {
      return res.status(400).json({
        success: false,
        message: 'All required fields must be provided: assignmentCode, studentCode, answers'
      });
    }

    // Validate answers array
    if (!Array.isArray(answers) || answers.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Answers must be a non-empty array'
      });
    }

    // Validate each answer
    for (const answer of answers) {
      if (!answer.questionNo || answer.answer === undefined || answer.answer === null) {
        return res.status(400).json({
          success: false,
          message: 'Each answer must have questionNo and answer fields'
        });
      }
    }

    // Find assignment
    const assignment = await Assignment.findOne({ assignmentCode });
    if (!assignment) {
      return res.status(404).json({
        success: false,
        message: 'Assignment not found'
      });
    }

    // Get or initialize submission for this student
    // Convert submissions to Map if it's an object
    let submissions = assignment.submissions;
    if (!(submissions instanceof Map)) {
      submissions = submissions ? new Map(Object.entries(submissions)) : new Map();
    }
    
    const studentSubmission = submissions.get(studentCode) || {
      answers: [],
      overallScore: null,
      submissionDate: null,
      teacherComments: null,
      summary: null,
      needPractice: [],
      topicUnderCovered: [],
      resources: [],
      status: 'pending'
    };

    // Update answers, set submission date, and set status to completed
    studentSubmission.answers = answers;
    studentSubmission.submissionDate = new Date();
    studentSubmission.status = 'submitted';

    // Save submission
    submissions.set(studentCode, studentSubmission);
    assignment.submissions = submissions;

    await assignment.save();

    res.status(200).json({
      success: true,
      message: 'Assignment submitted successfully',
      data: {
        assignmentCode: assignment.assignmentCode,
        studentCode: studentCode,
        submission: studentSubmission
      }
    });
  } catch (error) {
    console.error('Error submitting assignment:', error);
    res.status(500).json({
      success: false,
      message: 'Error submitting assignment',
      error: error.message
    });
  }
};

// Teacher Review
exports.reviewAssignment = async (req, res) => {
  try {
    const {
      assignmentCode,
      studentCode,
      overallScore,
      teacherComments,
      summary,
      needPractice,
      topicUnderCovered,
      resources,
      questionRatings
    } = req.body;

    // Validate required fields
    if (!assignmentCode || !studentCode) {
      return res.status(400).json({
        success: false,
        message: 'assignmentCode and studentCode are required'
      });
    }

    // Find assignment
    const assignment = await Assignment.findOne({ assignmentCode });
    if (!assignment) {
      return res.status(404).json({
        success: false,
        message: 'Assignment not found'
      });
    }

    // Get submissions
    // Convert submissions to Map if it's an object
    let submissions = assignment.submissions;
    if (!(submissions instanceof Map)) {
      submissions = submissions ? new Map(Object.entries(submissions)) : new Map();
    }
    
    const studentSubmission = submissions.get(studentCode);

    if (!studentSubmission || !studentSubmission.answers || studentSubmission.answers.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Student submission not found for this assignment'
      });
    }

    // Update question ratings if provided
    if (questionRatings && typeof questionRatings === 'object') {
      // Convert question key (q1, q2, etc.) to question number
      const questionKeyToNumber = (key) => {
        const match = key.match(/q(\d+)/i);
        return match ? parseInt(match[1]) : null;
      };

      // Update rate for each answer based on questionRatings
      studentSubmission.answers = studentSubmission.answers.map(answer => {
        // Try to find rating by question number or question key
        let rating = null;
        
        // Check if rating is provided with question number as key (e.g., "1": 6)
        if (questionRatings[answer.questionNo] !== undefined) {
          rating = questionRatings[answer.questionNo];
        }
        // Check if rating is provided with question key (e.g., "q1": 6)
        else {
          // Find matching key by question number
          for (const key in questionRatings) {
            const qNum = questionKeyToNumber(key);
            if (qNum === answer.questionNo) {
              rating = questionRatings[key];
              break;
            }
          }
        }

        // Update rate if rating is found and valid (0-10)
        if (rating !== null && rating !== undefined) {
          const rateValue = parseFloat(rating);
          if (!isNaN(rateValue) && rateValue >= 0 && rateValue <= 10) {
            answer.rate = rateValue;
          }
        }

        return answer;
      });
    }

    // Update review information
    if (overallScore !== undefined) {
      studentSubmission.overallScore = overallScore;
    }
    if (teacherComments !== undefined) {
      studentSubmission.teacherComments = teacherComments;
    }
    if (summary !== undefined) {
      studentSubmission.summary = summary;
    }
    if (needPractice !== undefined && Array.isArray(needPractice)) {
      studentSubmission.needPractice = needPractice;
    }
    if (topicUnderCovered !== undefined && Array.isArray(topicUnderCovered)) {
      studentSubmission.topicUnderCovered = topicUnderCovered;
    }
    if (resources !== undefined && Array.isArray(resources)) {
      studentSubmission.resources = resources;
    }

    // Update submission status to reviewed
    studentSubmission.status = 'reviewed';

    // Save updated submission
    submissions.set(studentCode, studentSubmission);
    assignment.submissions = submissions;

    await assignment.save();

    res.status(200).json({
      success: true,
      message: 'Assignment reviewed successfully',
      data: {
        assignmentCode: assignment.assignmentCode,
        studentCode: studentCode,
        submission: studentSubmission
      }
    });
  } catch (error) {
    console.error('Error reviewing assignment:', error);
    res.status(500).json({
      success: false,
      message: 'Error reviewing assignment',
      error: error.message
    });
  }
};

// Get all assignments
exports.getAllAssignments = async (req, res) => {
  try {
    const assignments = await Assignment.find().sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      message: 'Assignments retrieved successfully',
      count: assignments.length,
      data: assignments
    });
  } catch (error) {
    console.error('Error fetching assignments:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching assignments',
      error: error.message
    });
  }
};

// Get assignments by assignedTo
exports.getAssignmentsByAssignedTo = async (req, res) => {
  try {
    const { assignedTo } = req.params;

    // Validate assignedTo parameter
    if (!assignedTo) {
      return res.status(400).json({
        success: false,
        message: 'assignedTo parameter is required'
      });
    }

    // Find all assignments with the specified assignedTo value
    const assignments = await Assignment.find({ assignedTo }).sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      message: `Assignments assigned to '${assignedTo}' retrieved successfully`,
      count: assignments.length,
      assignedTo: assignedTo,
      data: assignments
    });
  } catch (error) {
    console.error('Error fetching assignments by assignedTo:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching assignments by assignedTo',
      error: error.message
    });
  }
};

// Get assignments by teacherCode
exports.getAssignmentsByTeacherCode = async (req, res) => {
  try {
    const { teacherCode } = req.params;

    // Validate teacherCode parameter
    if (!teacherCode) {
      return res.status(400).json({
        success: false,
        message: 'teacherCode parameter is required'
      });
    }

    // Find all assignments with the specified teacherCode
    const assignments = await Assignment.find({ teacherCode }).sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      message: `Assignments by teacher '${teacherCode}' retrieved successfully`,
      count: assignments.length,
      teacherCode: teacherCode,
      data: assignments
    });
  } catch (error) {
    console.error('Error fetching assignments by teacherCode:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching assignments by teacherCode',
      error: error.message
    });
  }
};

// Get all students who submitted an assignment
exports.getSubmittedStudents = async (req, res) => {
  try {
    const { assignmentCode } = req.params;

    // Validate assignmentCode parameter
    if (!assignmentCode) {
      return res.status(400).json({
        success: false,
        message: 'assignmentCode parameter is required'
      });
    }

    // Find the assignment
    const assignment = await Assignment.findOne({ assignmentCode });
    if (!assignment) {
      return res.status(404).json({
        success: false,
        message: 'Assignment not found'
      });
    }

    // Get submissions (convert to Map if it's an object)
    let submissions = assignment.submissions;
    if (!(submissions instanceof Map)) {
      submissions = submissions ? new Map(Object.entries(submissions)) : new Map();
    }

    // Extract all studentCodes from submissions map
    const studentCodes = Array.from(submissions.keys());

    if (studentCodes.length === 0) {
      return res.status(200).json({
        success: true,
        message: 'No students have submitted this assignment yet',
        count: 0,
        assignmentCode: assignmentCode,
        data: []
      });
    }

    // Find all users with matching userCode and role is "student"
    const students = await UserInformation.find({
      userCode: { $in: studentCodes },
      role: 'Student'
    }).select('-password').sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      message: `Students who submitted assignment '${assignmentCode}' retrieved successfully`,
      count: students.length,
      assignmentCode: assignmentCode,
      submittedCount: studentCodes.length,
      data: students
    });
  } catch (error) {
    console.error('Error fetching submitted students:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching submitted students',
      error: error.message
    });
  }
};

// Get assignment with specific student submission
exports.getAssignmentWithStudentSubmission = async (req, res) => {
  try {
    const { assignmentCode, studentCode } = req.params;

    // Validate parameters
    if (!assignmentCode || !studentCode) {
      return res.status(400).json({
        success: false,
        message: 'Both assignmentCode and studentCode parameters are required'
      });
    }

    // Find the assignment
    const assignment = await Assignment.findOne({ assignmentCode });
    if (!assignment) {
      return res.status(404).json({
        success: false,
        message: 'Assignment not found'
      });
    }

    // Get submissions (convert to Map if it's an object)
    let submissions = assignment.submissions;
    if (!(submissions instanceof Map)) {
      submissions = submissions ? new Map(Object.entries(submissions)) : new Map();
    }

    // Get the specific student's submission
    const studentSubmission = submissions.get(studentCode);

    // Convert assignment to object and remove all submissions
    const assignmentData = assignment.toObject();
    delete assignmentData.submissions;

    // Ensure questions are included (convert Map to object if needed)
    let questions = assignmentData.questions;
    if (questions instanceof Map) {
      questions = Object.fromEntries(questions);
    }

    // Add only the specific student's submission with questions
    const result = {
      ...assignmentData,
      questions: questions, // Explicitly include questions
      studentSubmission: studentSubmission || null
    };

    res.status(200).json({
      success: true,
      message: studentSubmission 
        ? `Assignment and student submission retrieved successfully`
        : `Assignment retrieved successfully, but no submission found for this student`,
      assignmentCode: assignmentCode,
      studentCode: studentCode,
      data: result
    });
  } catch (error) {
    console.error('Error fetching assignment with student submission:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching assignment with student submission',
      error: error.message
    });
  }
};

// Get student report with completed assignments and scores
exports.getStudentReport = async (req, res) => {
  try {
    const { studentCode } = req.params;

    // Validate studentCode parameter
    if (!studentCode) {
      return res.status(400).json({
        success: false,
        message: 'studentCode parameter is required'
      });
    }

    // Find student information
    const student = await UserInformation.findOne({ userCode: studentCode, role: 'Student' });
    if (!student) {
      return res.status(404).json({
        success: false,
        message: 'Student not found'
      });
    }

    // Find all assignments where this student has a submission
    const allAssignments = await Assignment.find();

    // Filter assignments where student has submitted
    const assignmentsWithSubmission = [];
    let totalScore = 0;
    let completedCount = 0;
    let pendingCount = 0;
    let reviewedCount = 0;

    for (const assignment of allAssignments) {
      // Convert submissions to Map if it's an object
      let submissions = assignment.submissions;
      if (!(submissions instanceof Map)) {
        submissions = submissions ? new Map(Object.entries(submissions)) : new Map();
      }

      // Check if student has a submission
      const studentSubmission = submissions.get(studentCode);
      
      if (studentSubmission) {
        // Check if submission is completed
        if (studentSubmission.status === 'completed') {
          completedCount++;
        } else {
          pendingCount++;
        }

        // Check if submission has been reviewed (has overallScore)
        if (studentSubmission.overallScore !== null && studentSubmission.overallScore !== undefined) {
          reviewedCount++;
          totalScore += studentSubmission.overallScore;
        }

        // Prepare assignment data with submission
        const assignmentData = assignment.toObject();
        delete assignmentData.submissions;

        assignmentsWithSubmission.push({
          assignment: {
            assignmentCode: assignment.assignmentCode,
            assignmentName: assignment.assignmentName,
            subject: assignment.subject,
            dueDate: assignment.dueDate,
            assignedTo: assignment.assignedTo,
            createdAt: assignment.createdAt
          },
          submission: {
            status: studentSubmission.status || 'pending',
            submissionDate: studentSubmission.submissionDate,
            overallScore: studentSubmission.overallScore,
            teacherComments: studentSubmission.teacherComments,
            summary: studentSubmission.summary,
            answers: studentSubmission.answers,
            needPractice: studentSubmission.needPractice,
            topicUnderCovered: studentSubmission.topicUnderCovered,
            resources: studentSubmission.resources
          }
        });
      }
    }

    // Calculate average score
    const averageScore = reviewedCount > 0 ? (totalScore / reviewedCount).toFixed(2) : 0;

    // Prepare student data without password
    const studentData = student.toObject();
    delete studentData.password;

    // Build report
    const report = {
      student: studentData,
      statistics: {
        totalAssignments: assignmentsWithSubmission.length,
        completedAssignments: completedCount,
        pendingAssignments: pendingCount,
        reviewedAssignments: reviewedCount,
        totalScore: totalScore,
        averageScore: parseFloat(averageScore)
      },
      assignments: assignmentsWithSubmission
    };

    res.status(200).json({
      success: true,
      message: `Student report retrieved successfully for ${studentData.fullName}`,
      studentCode: studentCode,
      data: report
    });
  } catch (error) {
    console.error('Error fetching student report:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching student report',
      error: error.message
    });
  }
};

// Get assignment by code
exports.getAssignmentByCode = async (req, res) => {
  try {
    const { assignmentCode } = req.params;

    const assignment = await Assignment.findOne({ assignmentCode });
    if (!assignment) {
      return res.status(404).json({
        success: false,
        message: 'Assignment not found'
      });
    }

    res.status(200).json({
      success: true,
      message: 'Assignment retrieved successfully',
      data: assignment
    });
  } catch (error) {
    console.error('Error fetching assignment:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching assignment',
      error: error.message
    });
  }
};

