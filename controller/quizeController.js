const Quize = require('../model/quize');
const UserInformation = require('../model/userInformation');

// Add Quiz
exports.addQuize = async (req, res) => {
  try {
    const { teacherCode, quizeName, subject, dueDate, assignedTo, questions } = req.body;

    // Validate required fields
    if (!teacherCode || !quizeName || !subject || !dueDate || !assignedTo) {
      return res.status(400).json({
        success: false,
        message: 'All required fields must be provided: teacherCode, quizeName, subject, dueDate, assignedTo'
      });
    }

    // Validate questions
    if (!questions || typeof questions !== 'object' || Object.keys(questions).length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Questions are required and must be an object'
      });
    }

    // Create quiz
    const quize = new Quize({
      teacherCode,
      quizeName,
      subject,
      dueDate,
      assignedTo,
      questions
      // quizeCode will be auto-generated by pre-save hook
    });

    await quize.save();

    res.status(201).json({
      success: true,
      message: 'Quiz created successfully',
      data: quize
    });
  } catch (error) {
    console.error('Error creating quiz:', error);
    res.status(500).json({
      success: false,
      message: 'Error creating quiz',
      error: error.message
    });
  }
};

// Student Submission
exports.submitQuize = async (req, res) => {
  try {
    const { quizeCode, studentCode, answers } = req.body;

    // Validate required fields
    if (!quizeCode || !studentCode || !answers) {
      return res.status(400).json({
        success: false,
        message: 'All required fields must be provided: quizeCode, studentCode, answers'
      });
    }

    // Validate answers array
    if (!Array.isArray(answers) || answers.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Answers must be a non-empty array'
      });
    }

    // Validate each answer
    for (const answer of answers) {
      if (!answer.questionNo || answer.answer === undefined || answer.answer === null) {
        return res.status(400).json({
          success: false,
          message: 'Each answer must have questionNo and answer fields'
        });
      }
    }

    // Find quiz
    const quize = await Quize.findOne({ quizeCode });
    if (!quize) {
      return res.status(404).json({
        success: false,
        message: 'Quiz not found'
      });
    }

    // Get or initialize submission for this student
    let submissions = quize.submissions;
    if (!(submissions instanceof Map)) {
      submissions = submissions ? new Map(Object.entries(submissions)) : new Map();
    }
    
    const studentSubmission = submissions.get(studentCode) || {
      answers: [],
      overallScore: null,
      submissionDate: null,
      teacherComments: null,
      status: 'pending',
      summary: null,
      needPractice: [],
      topicUnderCovered: [],
      resources: []
    };

    // Convert questions to Map if it's an object
    let questions = quize.questions;
    if (!(questions instanceof Map)) {
      questions = questions ? new Map(Object.entries(questions)) : new Map();
    }

    // Process answers and check if they match correct option
    const processedAnswers = answers.map(answer => {
      const question = questions.get(`q${answer.questionNo}`) || 
                      Array.from(questions.values()).find(q => q.questionNo === answer.questionNo);
      
      let match = false;
      if (question && question.correctOption) {
        // Check if the answer matches the correct option (case-insensitive)
        match = question.correctOption.trim().toLowerCase() === answer.answer.trim().toLowerCase();
      }

      return {
        questionNo: answer.questionNo,
        answer: answer.answer,
        match: match
      };
    });

    // Update answers, submission date, and status
    studentSubmission.answers = processedAnswers;
    studentSubmission.submissionDate = new Date();
    studentSubmission.status = 'completed';

    // Save submission
    submissions.set(studentCode, studentSubmission);
    quize.submissions = submissions;

    await quize.save();

    res.status(200).json({
      success: true,
      message: 'Quiz submitted successfully',
      data: {
        quizeCode: quize.quizeCode,
        studentCode: studentCode,
        submission: studentSubmission
      }
    });
  } catch (error) {
    console.error('Error submitting quiz:', error);
    res.status(500).json({
      success: false,
      message: 'Error submitting quiz',
      error: error.message
    });
  }
};

// Teacher Review
exports.reviewQuize = async (req, res) => {
  try {
    const {
      quizeCode,
      studentCode,
      overallScore,
      teacherComments,
      summary,
      needPractice,
      topicUnderCovered,
      resources
    } = req.body;

    // Validate required fields
    if (!quizeCode || !studentCode) {
      return res.status(400).json({
        success: false,
        message: 'quizeCode and studentCode are required'
      });
    }

    // Find quiz
    const quize = await Quize.findOne({ quizeCode });
    if (!quize) {
      return res.status(404).json({
        success: false,
        message: 'Quiz not found'
      });
    }

    // Get submissions
    let submissions = quize.submissions;
    if (!(submissions instanceof Map)) {
      submissions = submissions ? new Map(Object.entries(submissions)) : new Map();
    }
    
    const studentSubmission = submissions.get(studentCode);

    if (!studentSubmission || !studentSubmission.answers || studentSubmission.answers.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Student submission not found for this quiz'
      });
    }

    // Update review information
    if (overallScore !== undefined) {
      studentSubmission.overallScore = overallScore;
    }
    if (teacherComments !== undefined) {
      studentSubmission.teacherComments = teacherComments;
    }
    if (summary !== undefined) {
      studentSubmission.summary = summary;
    }
    if (needPractice !== undefined && Array.isArray(needPractice)) {
      studentSubmission.needPractice = needPractice;
    }
    if (topicUnderCovered !== undefined && Array.isArray(topicUnderCovered)) {
      studentSubmission.topicUnderCovered = topicUnderCovered;
    }
    if (resources !== undefined && Array.isArray(resources)) {
      studentSubmission.resources = resources;
    }

    // Save updated submission
    submissions.set(studentCode, studentSubmission);
    quize.submissions = submissions;

    await quize.save();

    res.status(200).json({
      success: true,
      message: 'Quiz reviewed successfully',
      data: {
        quizeCode: quize.quizeCode,
        studentCode: studentCode,
        submission: studentSubmission
      }
    });
  } catch (error) {
    console.error('Error reviewing quiz:', error);
    res.status(500).json({
      success: false,
      message: 'Error reviewing quiz',
      error: error.message
    });
  }
};

// Get all quizzes
exports.getAllQuizes = async (req, res) => {
  try {
    const quizes = await Quize.find().sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      message: 'Quizzes retrieved successfully',
      count: quizes.length,
      data: quizes
    });
  } catch (error) {
    console.error('Error fetching quizzes:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching quizzes',
      error: error.message
    });
  }
};

// Get quiz by code
exports.getQuizeByCode = async (req, res) => {
  try {
    const { quizeCode } = req.params;

    const quize = await Quize.findOne({ quizeCode });
    if (!quize) {
      return res.status(404).json({
        success: false,
        message: 'Quiz not found'
      });
    }

    res.status(200).json({
      success: true,
      message: 'Quiz retrieved successfully',
      data: quize
    });
  } catch (error) {
    console.error('Error fetching quiz:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching quiz',
      error: error.message
    });
  }
};

// Get quizzes by assignedTo
exports.getQuizesByAssignedTo = async (req, res) => {
  try {
    const { assignedTo } = req.params;

    if (!assignedTo) {
      return res.status(400).json({
        success: false,
        message: 'assignedTo parameter is required'
      });
    }

    const quizes = await Quize.find({ assignedTo }).sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      message: `Quizzes assigned to '${assignedTo}' retrieved successfully`,
      count: quizes.length,
      assignedTo: assignedTo,
      data: quizes
    });
  } catch (error) {
    console.error('Error fetching quizzes by assignedTo:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching quizzes by assignedTo',
      error: error.message
    });
  }
};

// Get quizzes by teacherCode
exports.getQuizesByTeacherCode = async (req, res) => {
  try {
    const { teacherCode } = req.params;

    if (!teacherCode) {
      return res.status(400).json({
        success: false,
        message: 'teacherCode parameter is required'
      });
    }

    const quizes = await Quize.find({ teacherCode }).sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      message: `Quizzes by teacher '${teacherCode}' retrieved successfully`,
      count: quizes.length,
      teacherCode: teacherCode,
      data: quizes
    });
  } catch (error) {
    console.error('Error fetching quizzes by teacherCode:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching quizzes by teacherCode',
      error: error.message
    });
  }
};

// Get all students who submitted a quiz
exports.getSubmittedStudents = async (req, res) => {
  try {
    const { quizeCode } = req.params;

    if (!quizeCode) {
      return res.status(400).json({
        success: false,
        message: 'quizeCode parameter is required'
      });
    }

    const quize = await Quize.findOne({ quizeCode });
    if (!quize) {
      return res.status(404).json({
        success: false,
        message: 'Quiz not found'
      });
    }

    let submissions = quize.submissions;
    if (!(submissions instanceof Map)) {
      submissions = submissions ? new Map(Object.entries(submissions)) : new Map();
    }

    const studentCodes = Array.from(submissions.keys());

    if (studentCodes.length === 0) {
      return res.status(200).json({
        success: true,
        message: 'No students have submitted this quiz yet',
        count: 0,
        quizeCode: quizeCode,
        data: []
      });
    }

    const students = await UserInformation.find({
      userCode: { $in: studentCodes },
      role: 'Student'
    }).select('-password').sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      message: `Students who submitted quiz '${quizeCode}' retrieved successfully`,
      count: students.length,
      quizeCode: quizeCode,
      submittedCount: studentCodes.length,
      data: students
    });
  } catch (error) {
    console.error('Error fetching submitted students:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching submitted students',
      error: error.message
    });
  }
};

// Get quiz with specific student submission
exports.getQuizeWithStudentSubmission = async (req, res) => {
  try {
    const { quizeCode, studentCode } = req.params;

    if (!quizeCode || !studentCode) {
      return res.status(400).json({
        success: false,
        message: 'Both quizeCode and studentCode parameters are required'
      });
    }

    const quize = await Quize.findOne({ quizeCode });
    if (!quize) {
      return res.status(404).json({
        success: false,
        message: 'Quiz not found'
      });
    }

    let submissions = quize.submissions;
    if (!(submissions instanceof Map)) {
      submissions = submissions ? new Map(Object.entries(submissions)) : new Map();
    }

    const studentSubmission = submissions.get(studentCode);

    const quizeData = quize.toObject();
    delete quizeData.submissions;

    // Ensure questions are included (convert Map to object if needed)
    let questions = quizeData.questions;
    if (questions instanceof Map) {
      questions = Object.fromEntries(questions);
    }

    const result = {
      ...quizeData,
      questions: questions,
      studentSubmission: studentSubmission || null
    };

    res.status(200).json({
      success: true,
      message: studentSubmission 
        ? `Quiz and student submission retrieved successfully`
        : `Quiz retrieved successfully, but no submission found for this student`,
      quizeCode: quizeCode,
      studentCode: studentCode,
      data: result
    });
  } catch (error) {
    console.error('Error fetching quiz with student submission:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching quiz with student submission',
      error: error.message
    });
  }
};

